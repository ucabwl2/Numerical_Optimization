% Solve scaled Lasso using adaptive PDHG.  The problem solved is
%            min_u    |u| + lambda || Du - b ||
%  Inputs...
%    D     : An 2D array containing the data matrix
%    b     : A column vector of measurements
%    lambda: A scalar, the regularization/sparsity parameter 
%    opts  : An optional argument for customizing the behavior of 
%              pdhg_adaptive
%  Outputs...
%    solution : The recovered sparse regression coefficients
%    out      : A struct containing convergence data generated by the
%                  function 'pdhg_adaptive' when it solved the problem.
%
%  This File requires that 'pdhg_adaptive.m' be in your current path. 
%
%  For an explanation of PDHG and how it applies to this problem, see
%    "Adaptive Primal-Dual Hybrid Gradient Methods for Saddle-Point
%    Problems"  available at <http://arxiv.org/abs/1305.0546>
%

function [ solution ,out ] = pdhg_scaledLasso( D,b,lambda, opts)

%%  Define ingredients for PDHG
[M,N] = size(D);
fProx = @(x,tau) x;    
gProx = @(y,sigma) [ min(1, max(-1,(y(1:N))));...
               projectIntoCircle(y(N+1:end)-sigma*b,lambda) ];
A = @(x) [x ; D*x];
At = @(y) y(1:N)+D'*y(N+1:end);

%%  Options for adaptive_pdhg
opts = [];
% f1 computes the value of the objective function
opts.f1 = @(x,y,x0,y0,tau,sigma) sum(abs(x))+lambda*norm(D*x-b,'fro');

%% initial guess
x0 = zeros(N,1);
y0 = zeros(N+M,1);

%% call solver
if ~exist('opts','var')
        opts = [];
end
[solution ,out]= pdhg_adaptive(x0,y0,A,At,fProx,gProx,opts); 

return


%%  Projext the vector x into a circle with radius 'rad'
function x = projectIntoCircle(x, rad)

n = norm(x,'fro');
if n>rad
    x = x/n*rad;
end

return;
