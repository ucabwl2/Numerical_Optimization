%  Solve Democratic/L-infinity minimization problem using adaptive PDHG
%  The TV denoising problem is.
%            min_u    ||u||_inf subject to ||Du-b||_2<eps
%  Inputs...
%       D   : A function handle (not matrix) that performs multiplication by
%              a matrix.
%       Dt  : A function handle to the adjoint of D
%       b   : A column vector, can be complex
%       eps : A positive scalar describing the L2 constraint
%       opts: An optional argument for customizing the behavior of 
%              pdhg_adaptive
%  Outputs...
%    sol : Solution to the minimization problem
%    out : A struct containing convergence data generated by the
%            function 'pdhg_adaptive' when it solved the problem.
% 
%
%  This File requires that 'pdhg_adaptive.m' and 'pdhg_Linfinity.m' be in 
%  your current path. 
%
%  For an explanation of PDHG and how it applies to this problem, see
%    "Adaptive Primal-Dual Hybrid Gradient Methods for Saddle-Point
%    Problems"  available at <http://arxiv.org/abs/1305.0546>
%

function [ sol,out ] = pdhg_Linfinity( D,Dt,b,eps,opts )

    %  Get problem dimensions
    M = length(b);
    N = length(Dt(b));
    
     %  This matrix computes Dx1-x2
    A = @(x) D(x(1:N)) - x(N+1:end);
    %  The transpose of A
    At = @(y) [Dt(y); - y];

    % This operator does both infinity norm prox on x1, and projection of
    % x2 onto the l2 ball of radius epsilon
    fProx = @(x, tau) [proxInf(x(1:N),tau); projectIntoCircle(x(N+1:end),eps)];
    % Handles the extra term involving b in the energy
    gProx = @(y,sigma) y-sigma*b;

    % Initial iterates
    x0 = zeros(N+M,1); % Contains both x1 and x2
    y0 = zeros(M,1);   % La
    if ~exist('opts','var')
        opts = [];
    end
    opts.f1 = @(x,y,x0,y0,tau,sigma) norm(x,'inf');


    [sol ,out]= pdhg_adaptive(x0,y0,A,At,fProx,gProx,opts); 
  
end

%%  Projext the vector x into a circle with radius 'rad'
function x = projectIntoCircle(x, rad)

n = norm(x,'fro');
if n>rad
    x = x/n*rad;
end

end

%% Perform prox operator:   min ||x||_inf + (1/2t)||x-w||^2
function [ xk ] = proxInf( w,t )
    N = length(w);
    wabs = abs(w);
    ws = (cumsum(sort(wabs,'descend'))- t)./(1:N)';
    alphaopt = max(ws);
    if alphaopt>0 
      xk = min(abs(w),alphaopt).*sign(w); % truncation step
    else
      xk = zeros(size(w)); % if t is big, then solution is zero
    end       
end

